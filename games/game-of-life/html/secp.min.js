!function(t){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).secp=t()}}((function(){return function t(e,r,n){function i(s,a){if(!r[s]){if(!e[s]){var c="function"==typeof require&&require;if(!a&&c)return c(s,!0);if(o)return o(s,!0);var f=new Error("Cannot find module '"+s+"'");throw f.code="MODULE_NOT_FOUND",f}var u=r[s]={exports:{}};e[s][0].call(u.exports,(function(t){return i(e[s][1][t]||t)}),u,u.exports,t,e,r,n)}return r[s].exports}for(var o="function"==typeof require&&require,s=0;s<n.length;s++)i(n[s]);return i}({1:[function(t,e,r){!function(t,n){"object"==typeof r&&void 0!==e?n(r):n((t="undefined"!=typeof globalThis?globalThis:t||self).nobleSecp256k1={})}(this,(function(t){"use strict";const e=BigInt(0),r=BigInt(1),n=BigInt(2),i=BigInt(3),o=BigInt(8),s=n**BigInt(256),a={a:e,b:BigInt(7),P:s-n**BigInt(32)-BigInt(977),n:s-BigInt("432420386565659656852420866394968145599"),h:r,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")};
/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */function c(t){const{a:e,b:r}=a,n=H(t*t),i=H(n*t);return H(i+e*t+r)}const f=a.a===e;class u{constructor(t,e,r){this.x=t,this.y=e,this.z=r}static fromAffine(t){if(!(t instanceof l))throw new TypeError("JacobianPoint#fromAffine: expected Point");return new u(t.x,t.y,r)}static toAffineBatch(t){const n=function(t,n=a.P){const i=new Array(t.length),o=P(t.reduce(((t,r,o)=>r===e?t:(i[o]=t,H(t*r,n))),r),n);return t.reduceRight(((t,r,o)=>r===e?t:(i[o]=H(t*i[o],n),H(t*r,n))),o),i}(t.map((t=>t.z)));return t.map(((t,e)=>t.toAffine(n[e])))}static normalizeZ(t){return u.toAffineBatch(t).map(u.fromAffine)}equals(t){if(!(t instanceof u))throw new TypeError("JacobianPoint expected");const{x:e,y:r,z:i}=this,{x:o,y:s,z:a}=t,c=H(i**n),f=H(a**n),h=H(e*f),l=H(o*c),d=H(H(r*a)*f),y=H(H(s*i)*c);return h===l&&d===y}negate(){return new u(this.x,H(-this.y),this.z)}double(){const{x:t,y:e,z:r}=this,s=H(t**n),a=H(e**n),c=H(a**n),f=H(n*(H((t+a)**n)-s-c)),h=H(i*s),l=H(h**n),d=H(l-n*f),y=H(h*(f-d)-o*c),w=H(n*e*r);return new u(d,y,w)}add(t){if(!(t instanceof u))throw new TypeError("JacobianPoint expected");const{x:r,y:i,z:o}=this,{x:s,y:a,z:c}=t;if(s===e||a===e)return this;if(r===e||i===e)return t;const f=H(o**n),h=H(c**n),l=H(r*h),d=H(s*f),y=H(H(i*c)*h),w=H(H(a*o)*f),g=H(d-l),p=H(w-y);if(g===e)return p===e?this.double():u.ZERO;const m=H(g**n),E=H(g*m),x=H(l*m),v=H(p**n-E-n*x),b=H(p*(x-v)-y*E),S=H(o*c*g);return new u(v,b,S)}subtract(t){return this.add(t.negate())}multiplyUnsafe(t){let n=R(t);const i=u.ZERO;if(n===e)return i;if(n===r)return this;if(!f){let t=i,o=this;for(;n>e;)n&r&&(t=t.add(o)),o=o.double(),n>>=r;return t}let{k1neg:o,k1:s,k2neg:c,k2:h}=$(n),l=i,d=i,y=this;for(;s>e||h>e;)s&r&&(l=l.add(y)),h&r&&(d=d.add(y)),y=y.double(),s>>=r,h>>=r;return o&&(l=l.negate()),c&&(d=d.negate()),d=new u(H(d.x*a.beta),d.y,d.z),l.add(d)}precomputeWindow(t){const e=f?128/t+1:256/t+1,r=[];let n=this,i=n;for(let o=0;o<e;o++){i=n,r.push(i);for(let e=1;e<2**(t-1);e++)i=i.add(n),r.push(i);n=i.double()}return r}wNAF(t,e){!e&&this.equals(u.BASE)&&(e=l.BASE);const n=e&&e._WINDOW_SIZE||1;if(256%n)throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");let i=e&&h.get(e);i||(i=this.precomputeWindow(n),e&&1!==n&&(i=u.normalizeZ(i),h.set(e,i)));let o=u.ZERO,s=u.ZERO;const a=1+(f?128/n:256/n),c=2**(n-1),d=BigInt(2**n-1),y=2**n,w=BigInt(n);for(let e=0;e<a;e++){const n=e*c;let a=Number(t&d);if(t>>=w,a>c&&(a-=y,t+=r),0===a){let t=i[n];e%2&&(t=t.negate()),s=s.add(t)}else{let t=i[n+Math.abs(a)-1];a<0&&(t=t.negate()),o=o.add(t)}}return{p:o,f:s}}multiply(t,e){let r,n,i=R(t);if(f){const{k1neg:t,k1:o,k2neg:s,k2:c}=$(i);let{p:f,f:h}=this.wNAF(o,e),{p:l,f:d}=this.wNAF(c,e);t&&(f=f.negate()),s&&(l=l.negate()),l=new u(H(l.x*a.beta),l.y,l.z),r=f.add(l),n=h.add(d)}else{const{p:t,f:o}=this.wNAF(i,e);r=t,n=o}return u.normalizeZ([r,n])[0]}toAffine(t=P(this.z)){const{x:e,y:n,z:i}=this,o=t,s=H(o*o),a=H(s*o),c=H(e*s),f=H(n*a);if(H(i*o)!==r)throw new Error("invZ was invalid");return new l(c,f)}}u.BASE=new u(a.Gx,a.Gy,r),u.ZERO=new u(e,r,e);const h=new WeakMap;class l{constructor(t,e){this.x=t,this.y=e}_setWindowSize(t){this._WINDOW_SIZE=t,h.delete(this)}static fromCompressedHex(t){const e=32===t.length,o=B(e?t:t.subarray(1));if(!V(o))throw new Error("Point is not on curve");let s=function(t){const{P:e}=a,r=BigInt(6),o=BigInt(11),s=BigInt(22),c=BigInt(23),f=BigInt(44),u=BigInt(88),h=t*t*t%e,l=h*h*t%e,d=U(l,i)*l%e,y=U(d,i)*l%e,w=U(y,n)*h%e,g=U(w,o)*w%e,p=U(g,s)*g%e,m=U(p,f)*p%e,E=U(m,u)*m%e,x=U(E,f)*p%e,v=U(x,i)*l%e,b=U(v,c)*g%e,S=U(b,r)*h%e;return U(S,n)}(c(o));const f=(s&r)===r;if(e)f&&(s=H(-s));else{1==(1&t[0])!==f&&(s=H(-s))}const u=new l(o,s);return u.assertValidity(),u}static fromUncompressedHex(t){const e=B(t.subarray(1,33)),r=B(t.subarray(33,65)),n=new l(e,r);return n.assertValidity(),n}static fromHex(t){const e=I(t),r=e.length,n=e[0];if(32===r||33===r&&(2===n||3===n))return this.fromCompressedHex(e);if(65===r&&4===n)return this.fromUncompressedHex(e);throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${r}`)}static fromPrivateKey(t){return l.BASE.multiply(O(t))}static fromSignature(t,r,n){const i=z(t=I(t)),{r:o,s:s}=Z(r);if(0!==n&&1!==n)throw new Error("Cannot recover signature: invalid recovery bit");if(i===e)throw new Error("Cannot recover signature: msgHash cannot be 0");const c=1&n?"03":"02",f=l.fromHex(c+x(o)),{n:u}=a,h=P(o,u),d=H(-i*h,u),y=H(s*h,u),w=l.BASE.multiplyAndAddUnsafe(f,d,y);if(!w)throw new Error("Cannot recover signature: point at infinify");return w.assertValidity(),w}toRawBytes(t=!1){return A(this.toHex(t))}toHex(t=!1){const e=x(this.x);if(t){return`${this.y&r?"03":"02"}${e}`}return`04${e}${x(this.y)}`}toHexX(){return this.toHex(!0).slice(2)}toRawX(){return this.toRawBytes(!0).slice(1)}assertValidity(){const t="Point is not on elliptic curve",{x:r,y:n}=this;if(!V(r)||!V(n))throw new Error(t);const i=H(n*n);if(H(i-c(r))!==e)throw new Error(t)}equals(t){return this.x===t.x&&this.y===t.y}negate(){return new l(this.x,H(-this.y))}double(){return u.fromAffine(this).double().toAffine()}add(t){return u.fromAffine(this).add(u.fromAffine(t)).toAffine()}subtract(t){return this.add(t.negate())}multiply(t){return u.fromAffine(this).multiply(t,this).toAffine()}multiplyAndAddUnsafe(t,e,r){const n=u.fromAffine(this).multiply(e),i=u.fromAffine(t).multiplyUnsafe(r),o=n.add(i);return o.equals(u.ZERO)?void 0:o.toAffine()}}function d(t){return Number.parseInt(t[0],16)>=8?"00"+t:t}function y(t){if(t.length<2||2!==t[0])throw new Error(`Invalid signature integer tag: ${E(t)}`);const e=t[1],r=t.subarray(2,e+2);if(!e||r.length!==e)throw new Error("Invalid signature integer: wrong length");if(0===r[0]&&r[1]<=127)throw new Error("Invalid signature integer: trailing length");return{data:B(r),left:t.subarray(e+2)}}l.BASE=new l(a.Gx,a.Gy),l.ZERO=new l(e,e);class w{constructor(t,e){this.r=t,this.s=e,this.assertValidity()}static fromCompact(t){const e=p(t),r="Signature.fromCompact";if("string"!=typeof t&&!e)throw new TypeError(`${r}: Expected string or Uint8Array`);const n=e?E(t):t;if(128!==n.length)throw new Error(`${r}: Expected 64-byte hex`);return new w(S(n.slice(0,64)),S(n.slice(64,128)))}static fromDER(t){const e=p(t);if("string"!=typeof t&&!e)throw new TypeError("Signature.fromDER: Expected string or Uint8Array");const{r:r,s:n}=function(t){if(t.length<2||48!=t[0])throw new Error(`Invalid signature tag: ${E(t)}`);if(t[1]!==t.length-2)throw new Error("Invalid signature: incorrect length");const{data:e,left:r}=y(t.subarray(2)),{data:n,left:i}=y(r);if(i.length)throw new Error(`Invalid signature: left bytes after parsing: ${E(i)}`);return{r:e,s:n}}(e?t:A(t));return new w(r,n)}static fromHex(t){return this.fromDER(t)}assertValidity(){const{r:t,s:e}=this;if(!C(t))throw new Error("Invalid Signature: r must be 0 < r < n");if(!C(e))throw new Error("Invalid Signature: s must be 0 < s < n")}hasHighS(){const t=a.n>>r;return this.s>t}normalizeS(){return this.hasHighS()?new w(this.r,a.n-this.s):this}toDERRawBytes(t=!1){return A(this.toDERHex(t))}toDERHex(t=!1){const e=d(b(this.s));if(t)return e;const r=d(b(this.r)),n=b(r.length/2),i=b(e.length/2);return`30${b(r.length/2+e.length/2+4)}02${n}${r}02${i}${e}`}toRawBytes(){return this.toDERRawBytes()}toHex(){return this.toDERHex()}toCompactRawBytes(){return A(this.toCompactHex())}toCompactHex(){return x(this.r)+x(this.s)}}function g(...t){if(!t.every(p))throw new Error("Uint8Array list expected");if(1===t.length)return t[0];const e=t.reduce(((t,e)=>t+e.length),0),r=new Uint8Array(e);for(let e=0,n=0;e<t.length;e++){const i=t[e];r.set(i,n),n+=i.length}return r}function p(t){return t instanceof Uint8Array}const m=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));function E(t){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");let e="";for(let r=0;r<t.length;r++)e+=m[t[r]];return e}function x(t){if(t>s)throw new Error("Expected number < 2^256");return t.toString(16).padStart(64,"0")}function v(t){return A(x(t))}function b(t){const e=t.toString(16);return 1&e.length?`0${e}`:e}function S(t){if("string"!=typeof t)throw new TypeError("hexToNumber: expected string, got "+typeof t);return BigInt(`0x${t}`)}function A(t){if("string"!=typeof t)throw new TypeError("hexToBytes: expected string, got "+typeof t);if(t.length%2)throw new Error("hexToBytes: received invalid unpadded hex"+t.length);const e=new Uint8Array(t.length/2);for(let r=0;r<e.length;r++){const n=2*r,i=t.slice(n,n+2),o=Number.parseInt(i,16);if(Number.isNaN(o)||o<0)throw new Error("Invalid byte sequence");e[r]=o}return e}function B(t){return S(E(t))}function I(t){return t instanceof Uint8Array?Uint8Array.from(t):A(t)}function R(t){if("number"==typeof t&&Number.isSafeInteger(t)&&t>0)return BigInt(t);if("bigint"==typeof t&&C(t))return t;throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n")}function H(t,r=a.P){const n=t%r;return n>=e?n:r+n}function U(t,r){const{P:n}=a;let i=t;for(;r-- >e;)i*=i,i%=n;return i}function P(t,n=a.P){if(t===e||n<=e)throw new Error(`invert: expected positive integers, got n=${t} mod=${n}`);let i=H(t,n),o=n,s=e,c=r;for(;i!==e;){const t=o%i,e=s-c*(o/i);o=i,i=t,s=c,c=e}if(o!==r)throw new Error("invert: does not exist");return H(s,n)}const k=(t,e)=>(t+e/n)/e,T=n**BigInt(128);function $(t){const{n:e}=a,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),i=-r*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=n,c=k(s*t,e),f=k(-i*t,e);let u=H(t-c*n-f*o,e),h=H(-c*i-f*s,e);const l=u>T,d=h>T;if(l&&(u=e-u),d&&(h=e-h),u>T||h>T)throw new Error("splitScalarEndo: Endomorphism failed, k="+t);return{k1neg:l,k1:u,k2neg:d,k2:h}}function z(t){const{n:e}=a,r=8*t.length-256;let n=B(t);return r>0&&(n>>=BigInt(r)),n>=e&&(n-=e),n}class N{constructor(){this.v=new Uint8Array(32).fill(1),this.k=new Uint8Array(32).fill(0),this.counter=0}hmac(...t){return rt.hmacSha256(this.k,...t)}hmacSync(...t){if("function"!=typeof rt.hmacSha256Sync)throw new Error("utils.hmacSha256Sync is undefined, you need to set it");const e=rt.hmacSha256Sync(this.k,...t);if(e instanceof Promise)throw new Error("To use sync sign(), ensure utils.hmacSha256 is sync");return e}incr(){if(this.counter>=1e3)throw new Error("Tried 1,000 k values for sign(), all were invalid");this.counter+=1}async reseed(t=new Uint8Array){this.k=await this.hmac(this.v,Uint8Array.from([0]),t),this.v=await this.hmac(this.v),0!==t.length&&(this.k=await this.hmac(this.v,Uint8Array.from([1]),t),this.v=await this.hmac(this.v))}reseedSync(t=new Uint8Array){this.k=this.hmacSync(this.v,Uint8Array.from([0]),t),this.v=this.hmacSync(this.v),0!==t.length&&(this.k=this.hmacSync(this.v,Uint8Array.from([1]),t),this.v=this.hmacSync(this.v))}async generate(){return this.incr(),this.v=await this.hmac(this.v),this.v}generateSync(){return this.incr(),this.v=this.hmacSync(this.v),this.v}}function C(t){return e<t&&t<a.n}function V(t){return e<t&&t<a.P}function D(t,n,i){const o=B(t);if(!C(o))return;const{n:s}=a,c=l.BASE.multiply(o),f=H(c.x,s);if(f===e)return;const u=H(P(o,s)*H(n+i*f,s),s);if(u===e)return;const h=new w(f,u);return{sig:h,recovery:(c.x===h.r?0:2)|Number(c.y&r)}}function O(t){let e;if("bigint"==typeof t)e=t;else if("number"==typeof t&&Number.isSafeInteger(t)&&t>0)e=BigInt(t);else if("string"==typeof t){if(64!==t.length)throw new Error("Expected 32 bytes of private key");e=S(t)}else{if(!p(t))throw new TypeError("Expected valid private key");if(32!==t.length)throw new Error("Expected 32 bytes of private key");e=B(t)}if(!C(e))throw new Error("Expected private key: 0 < key < n");return e}function K(t){return t instanceof l?(t.assertValidity(),t):l.fromHex(t)}function Z(t){if(t instanceof w)return t.assertValidity(),t;try{return w.fromDER(t)}catch(e){return w.fromCompact(t)}}function _(t){const e=p(t),r="string"==typeof t,n=(e||r)&&t.length;return e?33===n||65===n:r?66===n||130===n:t instanceof l}function W(t){return B(t.length>32?t.slice(0,32):t)}function q(t){const r=W(t),n=H(r,a.n);return F(n<e?r:n)}function F(t){if("bigint"!=typeof t)throw new Error("Expected bigint");return A(x(t))}function G(t,e,r){if(null==t)throw new Error(`sign: expected valid message hash, not "${t}"`);const n=I(t),i=O(e),o=[F(i),q(n)];if(null!=r){!0===r&&(r=rt.randomBytes(32));const t=I(r);if(32!==t.length)throw new Error("sign: Expected 32 bytes of extra data");o.push(t)}return{seed:g(...o),m:W(n),d:i}}function M(t,e){let{sig:r,recovery:n}=t;const{canonical:i,der:o,recovered:s}=Object.assign({canonical:!0,der:!0},e);i&&r.hasHighS()&&(r=r.normalizeS(),n^=1);const a=o?r.toDERRawBytes():r.toCompactRawBytes();return s?[a,n]:a}const X={strict:!0};async function j(t,...e){const r=new Uint8Array(t.split("").map((t=>t.charCodeAt(0)))),n=await rt.sha256(r);return B(await rt.sha256(g(n,n,...e)))}async function J(t,e,r){const n=v(t);return H(await j("BIP0340/challenge",n,e.toRawX(),r),a.n)}function L(t){return(t.y&r)===e}class Q{constructor(t,e){this.r=t,this.s=e,this.assertValidity()}static fromHex(t){const e=I(t);if(64!==e.length)throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${e.length}`);const r=B(e.subarray(0,32)),n=B(e.subarray(32,64));return new Q(r,n)}assertValidity(){const{r:t,s:e}=this;if(!V(t)||!C(e))throw new Error("Invalid signature")}toHex(){return x(this.r)+x(this.s)}toRawBytes(){return A(this.toHex())}}async function Y(t,e,r){const n=t instanceof Q;let i;try{i=n?t:Q.fromHex(t),n&&i.assertValidity()}catch(t){return!1}const{r:o,s:s}=i,c=I(e);let f;try{f=K(r)}catch(t){return!1}const u=await J(o,f,c),h=l.BASE.multiplyAndAddUnsafe(f,O(s),H(-u,a.n));return!(!h||!L(h)||h.x!==o)}const tt={Signature:Q,getPublicKey:function(t){return l.fromPrivateKey(t).toRawX()},sign:async function(t,r,n=rt.randomBytes()){if(null==t)throw new TypeError(`sign: Expected valid message, not "${t}"`);const{n:i}=a,o=I(t),s=O(r),c=I(n);if(32!==c.length)throw new TypeError("sign: Expected 32 bytes of aux randomness");const f=l.fromPrivateKey(s),u=L(f)?s:i-s,h=u^await j("BIP0340/aux",c),d=H(await j("BIP0340/nonce",v(h),f.toRawX(),o),i);if(d===e)throw new Error("sign: Creation of signature failed. k is zero");const y=l.fromPrivateKey(d),w=L(y)?d:i-d,g=await J(y.x,f,o),p=new Q(y.x,H(w+g*u,i)).toRawBytes();if(!await Y(p,o,f.toRawX()))throw new Error("sign: Invalid signature produced");return p},verify:Y};l.BASE._setWindowSize(8);const et={node:{},web:"object"==typeof self&&"crypto"in self?self.crypto:void 0},rt={isValidPrivateKey(t){try{return O(t),!0}catch(t){return!1}},hashToPrivateKey:t=>{if((t=I(t)).length<40||t.length>1024)throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");const n=H(B(t),a.n);if(n===e||n===r)throw new Error("Invalid private key");return v(n)},randomBytes:(t=32)=>{if(et.web)return et.web.getRandomValues(new Uint8Array(t));if(et.node){const{randomBytes:e}=et.node;return Uint8Array.from(e(t))}throw new Error("The environment doesn't have randomBytes function")},randomPrivateKey:()=>rt.hashToPrivateKey(rt.randomBytes(40)),bytesToHex:E,mod:H,sha256:async t=>{if(et.web){const e=await et.web.subtle.digest("SHA-256",t.buffer);return new Uint8Array(e)}if(et.node){const{createHash:e}=et.node;return Uint8Array.from(e("sha256").update(t).digest())}throw new Error("The environment doesn't have sha256 function")},hmacSha256:async(t,...e)=>{if(et.web){const r=await et.web.subtle.importKey("raw",t,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]),n=g(...e),i=await et.web.subtle.sign("HMAC",r,n);return new Uint8Array(i)}if(et.node){const{createHmac:r}=et.node,n=r("sha256",t);return e.forEach((t=>n.update(t))),Uint8Array.from(n.digest())}throw new Error("The environment doesn't have hmac-sha256 function")},sha256Sync:void 0,hmacSha256Sync:void 0,precompute(t=8,e=l.BASE){const r=e===l.BASE?e:new l(e.x,e.y);return r._setWindowSize(t),r.multiply(i),r}};t.CURVE=a,t.Point=l,t.Signature=w,t.getPublicKey=function(t,e=!1){return l.fromPrivateKey(t).toRawBytes(e)},t.getSharedSecret=function(t,e,r=!1){if(_(t))throw new TypeError("getSharedSecret: first arg must be private key");if(!_(e))throw new TypeError("getSharedSecret: second arg must be public key");const n=K(e);return n.assertValidity(),n.multiply(O(t)).toRawBytes(r)},t.recoverPublicKey=function(t,e,r,n=!1){return l.fromSignature(t,e,r).toRawBytes(n)},t.schnorr=tt,t.sign=async function(t,e,r={}){const{seed:n,m:i,d:o}=G(t,e,r.extraEntropy);let s;const a=new N;for(await a.reseed(n);!(s=D(await a.generate(),i,o));)await a.reseed();return M(s,r)},t.signSync=function(t,e,r={}){const{seed:n,m:i,d:o}=G(t,e,r.extraEntropy);let s;const a=new N;for(a.reseedSync(n);!(s=D(a.generateSync(),i,o));)a.reseedSync();return M(s,r)},t.utils=rt,t.verify=function(t,r,n,i=X){let o;try{o=Z(t),r=I(r)}catch(t){return!1}const{r:s,s:c}=o;if(i.strict&&o.hasHighS())return!1;const f=z(r);if(f===e)return!1;let u;try{u=K(n)}catch(t){return!1}const{n:h}=a,d=P(c,h),y=H(f*d,h),w=H(s*d,h),g=l.BASE.multiplyAndAddUnsafe(u,y,w);return!!g&&H(g.x,h)===s},Object.defineProperty(t,"__esModule",{value:!0})}))},{}]},{},[1])(1)}));
